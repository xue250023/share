概述
JS引擎执行过程
语法分析
预编译阶段
执行上下文栈
创建执行上下文
创建变量对象VO
建立作用域链ScopeChain
确定this指向
执行阶段
宏任务
微任务
EventLoop
概述
我们都知道, 在js中存在变量提升的情况, 例如如下这个例子



console.log(a)  // undefined

b() // 不会报错

var a = 1

function b() {}



这种简单的情况 只靠变量提升就可以解决，但复杂的情况呢，再来看一个例子

// 听说你变量提升很6 试试这道

function fn(a) {

     console.log(a)

     var a = 666

     function a() {}

     console.log(a)

     var b = function() {}

     console.log(b)

    function c() {}

}

fn(1)

显然 只靠变量提升已经解决不了了，需要更深入地了解js的运行方式。

JS引擎执行过程
js引擎的执行过程可以分为三个阶段

语法分析阶段
预编译阶段
执行阶段
本节课程的重心在预编译阶段以及执行阶段



语法分析
js脚本代码块加载完毕后，会首先进入语法分析阶段。该阶段主要作用是：分析该js脚本代码块的语法是否正确，如果不正确，则向外抛出一个语法错误（SyntaxError），停止该js代码块的执行；如果语法正确，则进入预编译阶段；

预编译阶段
在分析预编译阶段之前，我们先了解一下js的运行环境，运行环境主要有三种：

全局环境(脚本加载完以后， 首先进入的就是全局环境)
函数环境（某函数调用时，就会进入该函数的环境）
eval环境
每进入一个不同的运行环境都会创建一个相应的执行上下文，那么在一段JS程序中一般都会创建多个执行上下文，js引擎会以栈的方式对这些执行上下文进行处理，形成执行上下文栈，栈底永远是全局执行上下文，栈顶则永远是当前执行上下文。

执行上下文栈
顾名思义 执行上下文栈就是通过栈结构来管理执行上下文 特点就是先进后出

我们分析下段简单的代码来理解执行上下文栈：

function bar() {
    var B_context = "Bar EC";

    function foo() {
        var f_context = "foo EC";
    }

    foo()
}

bar()

我们来分析下： 
首先进入全局环境，创建全局执行上下文，推入stack栈中
调用bar函数，创建bar函数执行上下文，推入stack栈中
在bar函数内部调用foo函数，创建foo函数执行上下文，推入stack栈中
此刻由于foo函数内部没有再调用其他函数，那么则开始出栈
foo函数执行完毕后，栈顶foo函数执行上下文首先出栈
bar函数执行完毕，bar函数执行上下文出栈
全局执行上下文则在浏览器或者该标签页关闭时出栈。


创建执行上下文
在代码执行到不同的环境之前，会创建相应的执行上下文，例如进入全局环境之前会创建全局执行上下文，进入函数环境之前会创建函数执行上下文。而创建执行上下文主要做了以下三件事情。

创建变量对象VO
建立作用域链 Scope Chain
确定this指向
创建变量对象VO
创建变量对象又可以分为以下几个步骤

创建一个空AO对象
创建arguments对象 检查当前函数的参数 以键值对的形式怪载到AO对象上 只在函数（非箭头函数）执行上下文中有此过程
扫描当前作用域内所有的函数声明 挂在AO对象上，遇到重名的属性直接覆盖
扫描当前作用域内所有的var 声明的变量 变量名作为键 undefined作为值 挂在AO对象上，挂载时遇到重名的属性则忽略此挂载操作
function fn(a) {

     console.log(a)

     var a = 666

     function a() {}

     console.log(a)

     var b = function() {}

     console.log(b)

   function c() {}

}

fn(1)

AO {

a: 666,

c: function c() {},

b: function() {}

}

建立作用域链ScopeChain
作用域链可以简单的看成一个数组，数组的每一项都是一个AO对象。数组的第一项则是当前执行上下文的AO对象 第二项则是父级执行上下文的AO对象 依次类推，末尾项则是全局的AO对象 也叫 GO对象

有了该作用域链之后，在当前环境执行的时候，如果需要进行变量的访问 则会先去数组的第一项的AO对象中进行查找，找不到则从第二项的AO对象中进行查找。依次类推，直到GO对象为止 还找不到，就会报错

作用域链的创建过程如下： 

首先继承父级的作用域链，然后将当前环境的AO对象添加到作用域链的头部，如果把链条看作是数组，则就是一个unshift操作。

确定this指向
大多数情况下, 一句话搞定: 谁调用则指向谁。比如a.b() 则b内部的的this则指向a (不考虑箭头函数的情况，箭头函数内部的this和谁调用无关)

完整的判断逻辑如下：

首先判断是不是通过new来调用的，如果是 则 this指向返回的实例对象
再判断有没有通过bind apply call来修改this指向，如果有则this指向传入的值
然后判断如果是在上下文环境中调用，谁调用则指向谁
以上情况都不满足，则执行默认绑定 即 非严格模式下指向window上 严格模式下指向undefined上。
执行阶段
以上所有过程完毕以后，就会进入到执行阶段。而执行阶段的核心则是事件循环(event loop), 在执行过程中，并非只有js引擎线程，还会涉及到

事件触发线程
定时器触发线程
http异步请求线程
在了解事件循环之前，先了解下宏任务和微任务

宏任务
宏任务又按执行顺序分为同步任务和异步任务

同步任务也就是script整体代码
异步任务： 如setTimeout setInterval
微任务
微任务: promise.then promise.catch



EventLoop
来看下事件循环的具体过程

在JS引擎主线程执行过程中：

首先执行宏任务的同步任务，在主线程上形成一个执行栈，可理解为函数调用栈；
当执行栈中的函数调用到一些异步执行的API（例如异步Ajax，DOM事件，setTimeout等API），则会开启对应的线程（Http异步请求线程，事件触发线程和定时器触发线程）进行监控和控制
当异步任务的事件满足触发条件时(比如 异步请求有了结果，定时器时间到了)，对应的线程则会把该事件的处理函数推进任务队列，宏任务进入宏任务队列，微任务进入微任务队列中，等待主线程读取执行
当JS引擎主线程上的任务执行完毕，则会先检查微任务队列，如果有任务则会将微任务队列中的所有任务压入执行栈中依次执行，执行完再检查微任务队列直到微任务队列为空。微任务队列为空以后就回去检查宏任务队列，若不为空则取出队列中的第一个宏任务压入执行栈中执行，执行完再检查微任务队列，如此反复形成事件循环。